/**
 * Game of Life v1.4
 * Copyright 1996-2004 Edwin Martin <edwin@bitstorm.nl>
 * version 1.0 online since July 3 1996
 * @author Edwin Martin
 */

import java.awt.Canvas;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Event;
import java.awt.Frame;
import java.awt.Dialog;
import java.awt.FileDialog;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.FlowLayout;
import java.awt.GridLayout;
import java.awt.Image;
import java.awt.Menu;
import java.awt.MenuBar;
import java.awt.MenuItem;
import java.awt.Point;
import java.awt.Button;
import java.awt.Choice;
import java.awt.Label;
import java.awt.TextArea;
import java.awt.Panel;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentEvent;
import java.awt.event.ComponentListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;

require 'io'

/**
 * The Game of Life panel.
 * This is the heart of the program. It initializes everything and put it together.
 * @author Edwin Martin
 */
class GameOfLife extends Panel implements Runnable
{
    protected gameOfLifeFrame, gameOfLifeCanvas, gameOfLifeGrid;
    protected cellSize, cellCols, cellRows, genTime;
    protected controls;
    protected gridIO;
    protected static gameThread;

    /**
     * main() for Game of Life.
     */
    public static void main(args) {
        define game = new GameOfLife();
        define frame = new GameOfLifeFrame("Game of Life", game);

        game.init(frame);
        game.readShape(args.length > 0 ? args[0] : null);
        frame.pack();
        frame.show();
        frame.toFront();
    }

    /**
     * Initialize UI.
     */
    public void init(parent) {
        this.gameOfLifeFrame = parent;
        getParams();

        // set background colour
        setBackground(new Color(0x99'99'99));

        // create GameOfLifeGrid
        gameOfLifeGrid = new GameOfLifeGrid(cellCols, cellRows);
        gameOfLifeCanvas = new CellGridCanvas(gameOfLifeGrid, cellSize);
        gridIO = new GameOfLifeGridIO(gameOfLifeGrid);

        // create GameOfLifeControls
        controls = new GameOfLifeControls();
        controls.addGameOfLifeControlsListener(this);

        // put it all together
        define gridbag = new GridBagLayout();
        define canvasConstraints = new GridBagConstraints() {
            fill    : GridBagConstraints.BOTH,
            weightx : 1,
            weighty : 1,
            gridx   : GridBagConstraints.REMAINDER,
            gridy   : 0,
            anchor  : GridBagConstraints.CENTER,
        };
        setLayout(gridbag);
        gridbag.setConstraints(gameOfLifeCanvas, canvasConstraints);
        add(gameOfLifeCanvas);

        define controlsConstraints = new GridBagConstraints();
        canvasConstraints.gridx = GridBagConstraints.REMAINDER;
        canvasConstraints.gridy = 1;
        controlsConstraints.gridx = GridBagConstraints.REMAINDER;
        gridbag.setConstraints(controls, controlsConstraints);
        add(controls);

        setVisible(true);
        validate();
    }

    /**
     * Get params (cellSize, cellCols, cellRows, genTime) from system property.
     */
    protected void getParams() {
        cellSize = getParamInteger("cellsize", 11);
        cellCols = getParamInteger("cellcols", 50);
        cellRows = getParamInteger("cellrows", 30);
        genTime  = getParamInteger("gentime", 1000);
    }

    /**
     * Read parameter (int) or, when unavailable, get default value.
     * @param name name of parameter
     * @param defaultParam default when parameter is unavailable
     * @return value of parameter
     */
    protected getParamInteger(name, defaultParam) {
        define param = getParameter(name);
        return param == null ? defaultParam : int(param);
    }

    protected getParameter(param) {
        return System.getProperty(param);
    }

    /**
     * Set the shape.
     *
     * This is not done in init(), because the window resize in
     * GameOfLifeGridIO.setShape(Shape) needs a fully opened
     * window to do new size calculations.
     */
    public void readShape(filename = null) {
        if (filename != null) {
            gridIO.openShape(filename);
            reset();
        } else {
            setShape(ShapeCollection.getShapeByName("Glider"));
        }
    }

    /**
     * Get GameOfLifeGridIO
     */
    public getGridIO() {
        return gridIO;
    }

    /**
     * Starts creating new generations.
     */
    public void start() {
        controls.start();
        if (gameThread == null) {
            gameThread = new Thread(this);
            gameThread.start();
        }
    }

    /**
     * Stop generations.
     */
    public void stop() {
        controls.stop();
        gameThread = null;
    }

    /**
     * @see java.lang.Runnable#run()
     */
    public void run() {
        while (gameThread != null) {
            try {
                nextGeneration();
                Thread.sleep(genTime);
            } catch (ex) {
                ex.printStackTrace();
            }
        }
    }

    /**
     * Is the game running?
     */
    public isRunning() {
        return gameThread != null;
    }

    /**
     * Go go the next generation.
     */
    public void nextGeneration() {
        gameOfLifeGrid.next();
        gameOfLifeCanvas.repaint();
        showGenerations();
    }

    /**
     * Set the new shape.
     * @param shape name of shape.
     */
    public void setShape(shape) {
        if (shape != null) {
            gameOfLifeCanvas.shape = shape;
            reset();
        }
    }

    /**
     * Resets applet (after loading new shape)
     */
    public void reset() {
        stop(); // might otherwise confuse user
        gameOfLifeCanvas.repaint();
        showGenerations();
    }

    /**
     * Show number of generations.
     */
    private void showGenerations() {
        controls.showGeneration(gameOfLifeGrid.generations);
    }

    /**
     * Set speed of new generations.
     * @param fps generations per second
     */
    public void setSpeed(fps) {
        genTime = fps;
    }

    /**
     * Sets cell size.
     * @param p size of cell in pixels
     */
    public void setCellSize(p) {
        gameOfLifeCanvas.cellSize = cellSize = p;
    }

    /**
     * Gets cell size.
     * @return size of cell
     */
    public getCellSize() {
        return cellSize;
    }

    /**
     * Callback from GameOfLifeControlsListener
     */
    public void startStopButtonClicked(e) {
        isRunning() ? stop() : start();
    }

    /**
     * Callback from GameOfLifeControlsListener
     */
    public void nextButtonClicked(e) {
        nextGeneration();
    }

    /**
     * Callback from GameOfLifeControlsListener
     */
    public void speedChanged(e) {
        setSpeed(e.speed);
    }

    /**
     * Callback from GameOfLifeControlsListener
     */
    public void zoomChanged(e) {
        setCellSize(e.zoom);
    }

    /**
     * Callback from GameOfLifeControlsListener
     */
    public void shapeSelected(e) {
        define shapeName = e.shapeName;
        define shape = ShapeCollection.getShapeByName(shapeName);
        setShape(shape);
    }

    /**
    * File open and save operations for GameOfLifeGrid.
    */
    class GameOfLifeGridIO {
        public static final FILE_EXTENSION = ".cells";
        private grid, filename;

        /**
         * Constructor.
         * @param grid grid to read/write files from/to
         */
        public GameOfLifeGridIO(grid) {
            this.grid = grid;
        }

        /**
         * Load shape from disk
         * @param filename filename to load shape from, or null when no filename given.
         */
        public void openShape(filename = null) {
            define file;
            try {
                if (filename != null) {
                    file = new File(filename);
                } else {
                    define filedialog = new FileDialog(gameOfLifeFrame) {
                        title : "Open Game of Life file",
                        mode  : FileDialog.LOAD,
                        file  : this.filename
                    };
                    filedialog.show();

                    if (filedialog.file != null) {
                        this.filename = filedialog.file;
                        file = new File(filedialog.directory + this.filename);
                    } else {
                        return;
                    }
                }

                openShapeFile(file);
            } catch (ex) {
                ex.printStackTrace();
            }
        }

        /**
         * Read GameOfLife-file.
         */
        public void openShapeFile(file) {
            define shape = makeShape(file.name, file);
            setShape(shape);
        }

        /**
         * Set a shape and optionally resizes window.
         * @param shape Shape to set
         */
        public void setShape(shape) {
            define width, height;
            define shapeDim = shape.dimension;
            define gridDim = grid.dimension;

            if (shapeDim.width > gridDim.width || shapeDim.height > gridDim.height) {
                // Window has to be made larger
                define screenDim = getToolkit().screenSize;
                define frameDim = gameOfLifeFrame.size;
                define cellSize = getCellSize();
                // Calculate new window size
                width = frameDim.width + cellSize*(shapeDim.width-gridDim.width);
                height = frameDim.height + cellSize*(shapeDim.height-gridDim.height);
                // Does it fit on the screen?
                if (width > screenDim.width || height > screenDim.height) {
                    // With current cellSize, it doesn't fit on the screen.
                    // GameOfLifeControls.SIZE_SMALL corresponds with GameOfLifeControls.SMALL
                    define newCellSize = GameOfLifeControls.SIZE_SMALL;
                    width = frameDim.width + newCellSize*shapeDim.width - cellSize*gridDim.width;
                    height = frameDim.height + newCellSize*shapeDim.height - cellSize*gridDim.height;
                    // a little kludge to prevent de window from resizing twice
                    // setNewCellSize only has effect at the next resize
                    gameOfLifeCanvas.setAfterWindowResize(shape, newCellSize);
                    // The UI has to be adjusted, too
                    controls.setZoom(GameOfLifeControls.SMALL);
                } else {
                    // Now resize the window (and optionally set the new cellSize)
                    gameOfLifeCanvas.setAfterWindowResize(shape, cellSize);
                }
                if (width < 400)
                    width = 400;
                gameOfLifeFrame.setSize(width, height);
            } else {
                gameOfLifeCanvas.setShape(shape);
            }
        }

        /**
         * "Draw" the shape on the grid. (Okay, it's not really drawing).
         * The lines of text represents the cells of the shape.
         *
         * @param name name of shape
         * @param file text file
         */
        public makeShape(name, file) {
            define cells = [];
            define row = 0;

            grid.clear();
            file.eachLine { line =>
                if (line.startsWith("#") || line.startsWith("!"))
                    continue;

                for (i, c in line) {
                    if (c in [#'*',#'O',#'o',#'X',#'x',#'1']) {
                        cells << (i, row);
                    }
                }

                row++;
            }

            return new Shape(name, cells);
        }

        /**
         * Write shape to disk.
         */
        public void saveShape() {
            define colEnd = 0, rowEnd = 0;
            define dim = grid.dimension;
            define colStart = dim.width;
            define rowStart = dim.height;

            define lineSeperator = System.getProperty("line.separator");
            define text = new StringBuilder();
            text << "!Generator: Game of Life (http://www.bitstorm.org/gameoflife/)";
            text << lineSeperator;
            text << "!Variation: 23/3";
            text << lineSeperator;

            for (row in [0..*dim.height]) {
                for (col in [0..*dim.width]) {
                    if (grid.getCell(col, row)) {
                        if (row < rowStart)
                            rowStart = row;
                        if (col < colStart)
                            colStart = col;
                        if (row > rowEnd)
                            rowEnd = row;
                        if (col > colEnd)
                            colEnd = col;
                    }
                }
            }

            for (row in [rowStart..rowEnd]) {
                for (col in [colStart..colEnd]) {
                    text << (grid.getCell(col, row) ? 'O' : '-');
                }
                text << lineSeperator;
            }

            writeText(text.toString());
        }

        private void writeText(text) {
            define filepath;

            define filedialog = new FileDialog(gameOfLifeFrame) {
                title : "Save Game of Life file",
                mode  : FileDialog.SAVE,
                file  : this.filename
            };
            filedialog.show();

            if (filedialog.file != null) {
                this.filename = filedialog.file;
                filepath = filedialog.directory + this.filename;
                if (filepath.indexOf('.') == -1) {
                    filepath = filepath + FILE_EXTENSION;
                }

                define writer = new FileWriter(filepath);
                writer.write(text);
                writer.close();
            }
        }
    }
}

/**
 * The window with the applet. Extra is the menu bar.
 */
class GameOfLifeFrame extends Frame
{
    private applet;

    /**
     * Constructor.
     * @param title title of window
     * @param applet applet to show
     */
    public GameOfLifeFrame(title, applet) {
        super(title);
        this.applet = applet;

        enableEvents(Event.WINDOW_DESTROY);

        define menubar = new MenuBar();
        define fileMenu = new Menu("File", true);
        define readMenuItem = new MenuItem("Open...");
        readMenuItem.addActionListener(new ActionListener() {
            void actionPerformed(e) {
                getGameOfLife().getGridIO().openShape();
                getGameOfLife().reset();
            }
        });
        define writeMenuItem = new MenuItem("Save...");
        writeMenuItem.addActionListener(new ActionListener() {
            void actionPerformed(e) {
                getGameOfLife().getGridIO().saveShape();
            }
        });
        define quitMenuItem = new MenuItem("Exit");
        quitMenuItem.addActionListener(new ActionListener() {
            void actionPerformed(e) {
                System.exit(0);
            }
        });
        define helpMenu = new Menu("Help", true);
        define manualMenuItem = new MenuItem("Manual");
        manualMenuItem.addActionListener(new ActionListener() {
            void actionPerformed(e) {
                showManualDialog();
            }
        });
        define licenseMenuItem = new MenuItem("License");
        licenseMenuItem.addActionListener(new ActionListener() {
            void actionPerformed(e) {
                showLicenseDialog();
            }
        });
        define aboutMenuItem = new MenuItem("About");
        aboutMenuItem.addActionListener(new ActionListener() {
            void actionPerformed(e) {
                showAboutDialog();
            }
        });

        fileMenu.add(readMenuItem);
        fileMenu.add(writeMenuItem);
        fileMenu.addSeparator();
        fileMenu.add(quitMenuItem);
        helpMenu.add(manualMenuItem);
        helpMenu.add(licenseMenuItem);
        helpMenu.add(aboutMenuItem);
        menubar.add(fileMenu);
        menubar.add(helpMenu);

        define gridbag = new GridBagLayout();
        define appletConstraints = new GridBagConstraints() {
            fill : GridBagConstraints.BOTH,
            weightx : 1,
            weighty : 1
        }
        setLayout(gridbag);
        gridbag.setConstraints(applet, appletConstraints);
        setMenuBar(menubar);
        setResizable(true);
        add(applet);

        // center the window
        define screenSize = getToolkit().screenSize;
        if (screenSize.width >= 640 && screenSize.height >= 480) {
            setLocation((screenSize.width-550)/2, (screenSize.height-400)/2);
        }
    }

    /**
     * Process close window button.
     */
    public void processEvent(e) {
        if (e.getID() == Event.WINDOW_DESTROY) {
            System.exit(0);
        }
    }

    /**
     * Show about dialog.
     */
    private void showAboutDialog() {
        define ps = System.getProperties();
        define p = getLocation();
        new AboutDialog(this, "About the Game of Life",
                        ["Version 1.5 - Copyright 1996-2004 Edwin Martin",
                         "http://www.bitstorm.org/gameoflife/",
                         "Java VM ${ps['java.version']} from ${ps['java.vendor']}"
                        ],
                        p.x+100, p.y+60);
    }

    /**
     * Show manual.
     */
    private void showManualDialog() {
        define p = getLocation();
        new TextFileDialog(this, "Game of Life Manual", "manual.txt", p.x+60, p.y+60);
    }

    /**
     * Show license.
     */
    private void showLicenseDialog() {
        define p = getLocation();
        new TextFileDialog(this, "Game of Life License", "license.txt", p.x+60, p.y+60);
    }

    /**
     * Get GameOfLife object.
     */
    public getGameOfLife() {
        return applet;
    }
}

/**
 * Every cell in the grid is a Cell-object.
 * So it must be as small as possible.
 * Because every cell is pre-generated, no cells have to be generated
 * when the Game of Life play. Whether a cell is alive or not, is not
 * part of the Cell-object.
 */
class Cell(final col, final row) {
    /**
     * Number of neighbours of this cell.
     *
     * Determines the next state.
     */
    define neighbour = 0;

    /**
     * Compare cell-objects for use in hashtables
     */
    define equals(o) {
        return o is Cell and col==o.col and row == o.row;
    }

    /**
     * Calculate hash for use in hashtables
     */
    define hashCode() {
        return 5000*row+col;
    }
}

/**
 * Subclass of Canvas, which makes the cellgrid visible.
 * Communicates via CellGrid interface.
 */
class CellGridCanvas extends Canvas
{
    private cellUnderMouse = false;
    private offScreenImage;
    private offScreenGraphics;
    private offScreenGraphicsDrawed;
    private offScreenImageDrawed;
    private cellSize;
    private cellGrid;
    private listeners;
    private newCellSize = 0;
    private newShape;

    /**
     * Constructs a CellGridCanvas.
     * @param cellGrid the GoL cellgrid
     * @param cellSize size of cell in pixels
     */
    public CellGridCanvas(cellGrid, cellSize) {
        this.cellGrid = cellGrid;
        this.cellSize = cellSize;

        setBackground(new Color(0x99'99'99));

        addMouseListener(new MouseAdapter() {
            void mouseReleased(e) => draw(e.x, e.y);
            void mousePressed(e)  => saveCellUnderMouse(e.x, e.y);
        });
        addMouseMotionListener(new MouseMotionAdapter() {
            void mouseDragged(e) => draw(e.x, e.y);
        });
        addComponentListener(new ComponentListener() {
            void componentResized(e) {
                resized();
                repaint();
            }
            void componentMoved(e) {}
            void componentHidden(e) {}
            void componentShown(e) {}
        });
    }

    /**
     * Set cell size (zoom factor)
     * @param cellSize Size of cell in pixels
     */
    public void setCellSize(cellSize) {
        this.cellSize = cellSize;
        resized();
        repaint();
    }

    /**
     * The grid is resized (by widnow resize or zooming).
     * Also apply post-resize properties when necessary
     */
    public void resized() {
        if (newCellSize != 0) {
            cellSize = newCellSize;
            newCellSize = 0;
        }
        define canvasDim = this.size();
        offScreenImage = null;
        offScreenImageDrawed = null;
        cellGrid.resize(canvasDim.width div cellSize, canvasDim.height div cellSize);
        if (newShape != null) {
            setShape(newShape);
        }
    }

    /**
     * Remember state of cell for drawing.
     *
     * @param x x-coordinate
     * @param y y-coordinate
     */
    public void saveCellUnderMouse(x, y) {
        cellUnderMouse = cellGrid.getCell(x div cellSize, y div cellSize);
    }

    /**
     * Draw in this cell.
     *
     * @param x x-coordinate
     * @param y y-coordinate
     */
    public void draw(x, y) {
        cellGrid.setCell(x div cellSize, y div cellSize, !cellUnderMouse);
        repaint();
    }

    /**
     * Use double buffering.
     */
    public void update(g) {
        define d = getSize();
        if (offScreenImage == null) {
            offScreenImage = createImage(d.width, d.height);
            offScreenGraphics = offScreenImage.getGraphics();
        }
        paint(offScreenGraphics);
        g.drawImage(offScreenImage, 0, 0, null);
    }

    /**
     * Draw this generation.
     */
    public void paint(g) {
        // Draw grid on background image, which is faster
        if (offScreenImageDrawed == null) {
            define dim = cellGrid.dimension;
            define d = getSize();
            offScreenImageDrawed = createImage(d.width, d.height);
            offScreenGraphicsDrawed = offScreenImageDrawed.getGraphics();
            // draw background
            offScreenGraphicsDrawed.color = getBackground();
            offScreenGraphicsDrawed.fillRect(0, 0, d.width, d.height);
            offScreenGraphicsDrawed.color = Color.gray;
            offScreenGraphicsDrawed.fillRect(0, 0, cellSize*dim.width-1, cellSize*dim.height-1);
            offScreenGraphicsDrawed.color = getBackground();
            for (x in [1..*dim.width]) {
                offScreenGraphicsDrawed.drawLine(x*cellSize-1, 0, x*cellSize-1, cellSize*dim.height-1);
            }
            for (y in [1..*dim.height]) {
                offScreenGraphicsDrawed.drawLine(0, y*cellSize-1, cellSize*dim.width-1, y*cellSize-1);
            }
        }
        g.drawImage(offScreenImageDrawed, 0, 0, null);
        // draw populated cells
        g.color = Color.yellow;
        for (c in cellGrid.cells) {
            g.fillRect(c.col*cellSize, c.row*cellSize, cellSize-1, cellSize-1);
        }
    }

    /**
     * This is the preferred size.
     */
    public getPreferredSize() {
        define dim = cellGrid.dimension;
        return new Dimension(cellSize*dim.width, cellSize*dim.height);
    }

    /**
     * This is the minimum size (size of one cell).
     */
    public getMinimumSize() {
        return new Dimension(cellSize, cellSize);
    }

    /**
     * Settings to apply after a window-resize.
     * @param newShape new shape
     * @param newCellSize new cellSize
     */
    public void setAfterWindowResize(newShape, newCellSize) {
        this.newShape = newShape;
        this.newCellSize = newCellSize;
    }

    /**
     * Draws shape in grid.
     *
     * @param shape name of shape
     * @return true when shape fits, false otherwise
     */
    public void setShape(shape) {
        /// get shape properties
        define dimShape = shape.dimension;
        define dimGrid  = cellGrid.dimension;

        if (dimShape.width > dimGrid.width || dimShape.height > dimGrid.height) {
            throw "Shape doesn't fit on canvas (grid: ${dimGrid.width}x${dimGrid.height}, shape: ${dimShape.width}x${dimShape.height})";
        }

        // center the shape
        define xOffset = (dimGrid.width - dimShape.width) div 2;
        define yOffset = (dimGrid.height - dimShape.height) div 2;
        cellGrid.clear();

        // draw shape
        for (cell in shape.cells) {
            cellGrid.setCell(xOffset+cell[0], yOffset+cell[1], true);
        }
    }
}  

/**
 * GUI-controls of the Game of Life.
 * It contains controls like Shape, zoom and speed selector, next and start/stop button.
 * It is a seperate class, so it can be replaced by another implementation for e.g.
 * mobile phone or PDA's.
 * Communicates via the GameOfLifeControlsListener.
 */
class GameOfLifeControls extends Panel 
{
    private static final genLabelText = "Generations: ";
    private static final nextLabelText = "Next";
    private static final startLabelText = "Start";
    private static final stopLabelText = "Stop";

    public static final SLOW = "Slow";
    public static final FAST = "Fast";
    public static final HYPER = "Hyper";
    public static final BIG = "Big";
    public static final MEDIUM = "Medium";
    public static final SMALL = "Small";
    public static final SIZE_BIG = 11;
    public static final SIZE_MEDIUM = 7;
    public static final SIZE_SMALL = 3;

    private genLabel;
    private startstopButton, nextButton;
    private shapesChoice, zoomChoice;
    private listeners = [];

    /**
     * Constructs the controls.
     */
    public GameOfLifeControls() {
        // pulldown menu with shapes
        shapesChoice = new Choice();

        // Put names of shapes in menu
        for (shape in ShapeCollection.getShapes()) {
            shapesChoice.addItem(shape.name);
        }

        // when shape is selected
        shapesChoice.addItemListener(new ItemListener() {
            void itemStateChanged(e) {
                shapeSelected(e.item);
            }
        });

        // pulldown menu with speeds
        define speedChoice = new Choice();

        // add speeds
        speedChoice.addItem(SLOW);
        speedChoice.addItem(FAST);
        speedChoice.addItem(HYPER);

        // when item is selected
        speedChoice.addItemListener(new ItemListener() {
            void itemStateChanged(e) {
                switch (e.item) {
                case SLOW:  speedChanged(1000);
                case FAST:  speedChanged(100);
                case HYPER: speedChanged(10);
                }
            }
        });

        // pulldown menu with speeds
        zoomChoice = new Choice();

        // add items
        zoomChoice.addItem(BIG);
        zoomChoice.addItem(MEDIUM);
        zoomChoice.addItem(SMALL);

        // when item is selected
        zoomChoice.addItemListener(new ItemListener() {
            void itemStateChanged(e) {
                switch (e.item) {
                case BIG:    zoomChanged(SIZE_BIG);
                case MEDIUM: zoomChanged(SIZE_MEDIUM);
                case SMALL:  zoomChanged(SIZE_SMALL);
                }
            }
        });

        // number of generations
        genLabel = new Label(genLabelText + "        ");

        // start and stop button
        startstopButton = new Button(startLabelText);
        startstopButton.addActionListener(new ActionListener() {
            void actionPerformed(e) => startStopButtonClicked();
        });

        // next generation button
        nextButton = new Button(nextLabelText);
        nextButton.addActionListener(new ActionListener() {
            void actionPerformed(e) => nextButtonClicked();
        });

        // create panel with controls
        this.add(shapesChoice);
        this.add(nextButton);
        this.add(startstopButton);
        this.add(speedChoice);
        this.add(zoomChoice);
        this.add(genLabel);
        this.validate();
    }

    /**
     * Add listener for this control.
     * @param listener Listener object
     */
    public void addGameOfLifeControlsListener(listener) {
        listeners.add(listener);
    }

    /**
     * Remove listener from this control.
     * @param listener Listener object.
     */
    public void removeGameOfControlsListener(listener) {
        listeners.remove(listener);
    }

    /**
     * Set the number of generations in the control bar.
     * @param generations number of generations
     */
    public void showGeneration(generations) {
        genLabel.text = genLabelText + generations + "      ";
    }

    /**
     * Start-button is activated.
     */
    public void start() {
        startstopButton.label = stopLabelText;
        nextButton.disable();
        shapesChoice.disable();
    }

    /**
     * Stop-button is activated.
     */
    public void stop() {
        startstopButton.label = startLabelText;
        nextButton.enable();
        shapesChoice.enable();
    }

    /**
     * Called when the start/stop-button is clicked.
     * Notify event-listeners.
     */
    public void startStopButtonClicked() {
        define event = new GameOfLifeControlsEvent(this);
        listeners.each{$.startStopButtonClicked(event)};
    }

    /**
     * Called when the next-button is clicked.
     * Notify event-listeners.
     */
    public void nextButtonClicked() {
        define event = new GameOfLifeControlsEvent(this);
        listeners.each{$.nextButtonClicked(event)};
    }

    /**
     * Called when a new speed from the speed pull down is selected.
     * Notify event-listeners.
     */
    public void speedChanged(speed) {
        define event = GameOfLifeControlsEvent.getSpeedChangedEvent(this, speed);
        listeners.each{$.speedChanged(event)};
    }

    /**
     * Called when a new zoom from the zoom pull down is selected.
     * Notify event-listeners.
     */
    public void zoomChanged(zoom) {
        define event = GameOfLifeControlsEvent.getZoomChangedEvent(this, zoom);
        listeners.each{$.zoomChanged(event)};
    }

    /**
     * Called when a new shape from the shape pull down is selected.
     * Notify event-listeners.
     */
    public void shapeSelected(shapeName) {
        define event = GameOfLifeControlsEvent.getShapeSelectedEvent(this, shapeName);
        listeners.each{$.shapeSelected(event)};
    }

    /**
     * Called when a new cell size from the zoom pull down is selected.
     * Notify event-listeners.
     */
    public void setZoom(n) {
        zoomChoice.select(n);
    }
}

/**
 * Event class for GameOfLifeControls.
 * Can pass speed, cellSize and shapeName.
 * Objects from this class are generated by GameOfLifeControls.
 */
class GameOfLifeControlsEvent extends java.awt.Event
{
    private speed, zoom, shapeName;

    /**
     * Construct a GameOfLifeControls.ControlsEvent
     * @param source source of event
     */
    public GameOfLifeControlsEvent(source) {
        super(source, 0, null);
    }

    /**
     * Constructs a event due to the speed changed.
     * @param source source of the event
     * @param speed new speed
     * @return new event object
     */
    public static getSpeedChangedEvent(source, speed) {
        define event = new GameOfLifeControlsEvent(source);
        event.speed = speed;
        return event;
    }

    /**
     * Constructs a event due to the zoom changed.
     * @param source source of the event
     * @param zoom new zoom (cell size in pixels)
     * @return new event object
     */
    public static getZoomChangedEvent(source, zoom) {
        define event = new GameOfLifeControlsEvent(source);
        event.zoom = zoom;
        return event;
    }

    /**
     * Constructs a new event due to the shape changed.
     * @param source source of the event
     * @param shapeName name of selected shape
     * @return new event object
     */
    public static getShapeSelectedEvent(source, shapeName) {
        define event = new GameOfLifeControlsEvent(source);
        event.shapeName = shapeName;
        return event;
    }

    public getSpeed() => speed;
    public void setSpeed(speed) => this.speed = speed;
    public getZoom() => zoom;
    public void setZoom(zoom) => this.zoom = zoom;
    public getShapeName() => shapeName;
    public void setShapeName(shapeName) => this.shapeName = shapeName;
}

/**
 * Contains the cellgrid, the current shape and the Game Of Life algorithm that changes it.
 */
class GameOfLifeGrid
{
    private cellRows, cellCols;
    private generations;
    private currentShape, nextShape;
    private grid;

    /**
     * Constructs a GameOfLifeGrid.
     *
     * @param cellCols number of columns
     * @param cellRows number of rows
     */
    public GameOfLifeGrid(cellCols, cellRows) {
        this.cellCols = cellCols;
        this.cellRows = cellRows;
        this.generations = 0;
        this.currentShape = Collections.synchronizedSet(new HashSet());
        this.nextShape = Collections.synchronizedSet(new HashSet());

        grid = new Object[cellCols];
        for (c in [0..*cellCols]) {
            grid[c] = new Object[cellRows];
            for (r in [0..*cellRows]) {
                grid[c][r] = new Cell(c, r);
            }
        }
    }

    /**
     * Clears grid.
     */
    public void clear() {
        generations = 0;
        currentShape.clear();
        nextShape.clear();
    }

    /**
     * Create new generation of shape.
     */
    public void next() {
        generations++;
        nextShape.clear();

        // Reset cells
        currentShape.each { x => x.neighbour = 0 };

        // Add neighbours
        currentShape.each { Cell(col,row) =>
            addNeighbour(col-1, row-1);
            addNeighbour(col, row-1);
            addNeighbour(col+1, row-1);
            addNeighbour(col-1, row);
            addNeighbour(col+1, row);
            addNeighbour(col-1, row+1);
            addNeighbour(col, row+1);
            addNeighbour(col+1, row+1);
        };

        // Bury the dead
        currentShape.removeIf(\x=>x.neighbour not in [2..3]);

        // Bring out the new borns
        nextShape.each { x@Cell(col,row) =>
            if (x.neighbour == 3) {
                setCell(col, row, true);
            }
        };
    }

    /**
     * Adds a new neighbour to a cell.
     *
     * @param col Cell-column
     * @param row Cell-row
     */
    public void addNeighbour(col, row) {
        define c = grid[col][row];
        if (c != null) {
            if (c in nextShape) {
                c.neighbour++;
            } else {
                c.neighbour = 1;
                nextShape.add(c);
            }
        }
    }

    /**
     * Get cells.
     */
    public getCells() {
        return currentShape;
    }

    /**
     * Get value of cell.
     * @param col x-coordinate of cell
     * @param row y-coordinate of cell
     * @return value of cell
     */
    public getCell(col, row) {
        grid[col][row] in currentShape;
    }

    /**
     * Set value of cell.
     * @param col x-coordinate of cell
     * @param row y-coordinate of cell
     * @param c value of cell
     */
    public void setCell(col, row, c) {
        define cell = grid[col][row];
        if (cell != null) {
            if (c) {
                currentShape.add(cell);
            } else {
                currentShape.remove(cell);
            }
        }
    }

    /**
     * Get number of generations.
     */
    public getGenerations() {
        return generations;
    }

    /**
     * Get dimension of grid.
     */
    public getDimension() {
        return new Dimension(cellCols, cellRows);
    }

    /**
     * Resize grid. Reuse existing cells.
     */
    public void resize(cellColsNew, cellRowsNew) {
        if (cellCols == cellColsNew && cellRows == cellRowsNew)
            return;

        // Create a new grid, reusing existing Cell's
        define gridNew = new Object[cellColsNew];
        for (c in [0..*cellColsNew]) {
            gridNew[c] = new Object[cellRowsNew];
            for (r in [0..*cellRowsNew]) {
                if (c < cellCols && r < cellRows) {
                    gridNew[c][r] = grid[c][r];
                } else {
                    gridNew[c][r] = new Cell(c, r);
                }
            }
        }

        // Copy existing shape to center of new shape
        define colOffset = (cellColsNew-cellCols) div 2;
        define rowOffset = (cellRowsNew-cellRows) div 2;
        nextShape.clear();
        currentShape.each {
            define c = gridNew[$.col + colOffset][$.row + rowOffset];
            if (c != null) {
                nextShape.add(c);
            }
        };

        // Copy new grid to working grid
        grid = gridNew;
        currentShape.clear();
        currentShape.addAll(nextShape);

        cellCols = cellColsNew;
        cellRows = cellRowsNew;
    }
}

/**
 * Shape contains data of one (predefined) shape.
 */
class Shape(final name, final cells)
{
    /**
     * Get dimension of shape.
     */
    public getDimension() {
        define shapeWidth = 0;
        define shapeHeight = 0;
        for (cell in cells) {
            if (cell[0] > shapeWidth)
                shapeWidth = cell[0];
            if (cell[1] > shapeHeight)
                shapeHeight = cell[1];
        }
        return new Dimension(shapeWidth+1, shapeHeight+1);
    }
}

/**
 * Contains some nice Game of Life shapes.
 */
class ShapeCollection
{
    private static final COLLECTION = [
        new Shape("Clear", []),
        new Shape("Glider", [(1,0), (2,1), (2,2), (1,2), (0,2)]),
        new Shape("Small Exploder", [(0,1),(0,2),(1,0),(1,1),(1,3),(2,1),(2,2)]),
        new Shape("Exploder", [(0,0),(0,1),(0,2),(0,3),(0,4),(2,0),(2,4),(4,0),(4,1),(4,2),(4,3),(4,4)]),
        new Shape("10 Cell Row", [(0,0),(1,0),(2,0),(3,0),(4,0),(5,0),(6,0),(7,0),(8,0),(9,0)]),
        new Shape("Lightweight spaceship", [(0,1),(0,3),(1,0),(2,0),(3,0),(3,3),(4,0),(4,1),(4,2)]),
        new Shape("Tumbler", [(0,3),(0,4),(0,5),(1,0),(1,1),(1,5),(2,0),(2,1),(2,2),(2,3),(2,4),(4,0),(4,1),(4,2),(4,3),(4,4),(5,0),(5,1),(5,5),(6,3),(6,4),(6,5)]),
        new Shape("Gosper Glider Gun", [(0,2),(0,3),(1,2),(1,3),(8,3),(8,4),(9,2),(9,4),(10,2),(10,3),(16,4),(16,5),(16,6),(17,4),(18,5),(22,1),(22,2),(23,0),(23,2),(24,0),(24,1),(24,12),(24,13),(25,12),(25,14),(26,12),(34,0),(34,1),(35,0),(35,1),(35,7),(35,8),(35,9),(36,7),(37,8)])
    ];

    /**
     * Get array of shapes.
     */
    public static getShapes() {
        return COLLECTION;
    }

    /**
     * Get shape by its name.
     * @param name name of shape
     * @return shape object
     */
    public static getShapeByName(name) {
        return COLLECTION.find {name == $.name};
    }
}

/**
 * Shows a constructed About dialog box.
 * The dialog box can contain an image and several lines of text.
 */
class AboutDialog extends Dialog
{
    define okButton;

    /**
     * Construct an AboutDialog.
     * @param parent parent Frame
     * @param title title of dialog
     * @param posX x-coordinate
     * @param posY y-coordinate
     */
    public AboutDialog(parent, title, lines, posX, posY) {
        super(parent, title, false);

        okButton = new Button("   OK   ");
        okButton.addActionListener(new ActionListener() {
            actionPerformed(e) => close();
        });

        define gridbag = new GridBagLayout();
        setLayout(gridbag);

        define buttonPanel = new Panel();
        buttonPanel.setLayout(new FlowLayout(FlowLayout.CENTER));
        buttonPanel.add(okButton);

        define textPanel = new Panel();
        textPanel.setLayout(new GridLayout(lines.length, 1));
        lines.each { line => textPanel.add(new Label(line)) };

        gridbag.setConstraints(textPanel, 
            new GridBagConstraints() {
                fill    : GridBagConstraints.NONE,
                weightx : 0,
                weighty : 0,
                gridx   : GridBagConstraints.REMAINDER,
                gridy   : 1
            });
        add(textPanel);

        gridbag.setConstraints(buttonPanel,
            new GridBagConstraints() {
                fill    : GridBagConstraints.NONE,
                weightx : 0,
                weighty : 0,
                gridx   : GridBagConstraints.REMAINDER,
                gridy   : 2
            });
        add(buttonPanel);

        enableEvents(Event.WINDOW_DESTROY);
        setResizable(false);
        setModal(true);
        pack();
        setLocation(posX, posY);
        show();
    }

    /**
     * Close dialog box.
     */
    private void close() {
        this.hide();
        this.dispose();
    }

    /**
     * Process close window button.
     */
    public void processEvent(e) {
        if (e.getID() == Event.WINDOW_DESTROY)
            close();
    }
}

/**
 * Shows a text file in a dialog box.
 * It has a vertical scrollbar and a close button.
 */
class TextFileDialog extends Dialog
{
    /**
     * Constructs a TextFileDialog.
     * @param parent parent frame
     * @param title window title
     * @param filename filename to show
     */
    public TextFileDialog(parent, title, filename, posX, posY) {
        super(parent, title);

        define okButton = new Button(" Close ");
        okButton.addActionListener(new ActionListener() {
            void actionPerformed(e) => close();
        });

        define buf = new StringBuilder();
        new File(filename).eachLine { buf << $ << "\n" };
        define text = buf.toString();

        define textArea = new TextArea(text, 20, 50, TextArea.SCROLLBARS_VERTICAL_ONLY);
        textArea.background = Color.white;
        textArea.foreground = Color.black;
        textArea.editable = false;

        define buttonPanel = new Panel();
        buttonPanel.layout = new FlowLayout(FlowLayout.CENTER);
        buttonPanel.add(okButton);

        this.add("Center", textArea);
        this.add("South", buttonPanel);
        this.pack();
        this.enableEvents(Event.WINDOW_DESTROY);
        this.setLocation(posX, posY);
        this.show();
    }

    /**
     * Close dialog box.
     */
    private void close() {
        this.hide();
        this.dispose();
    }

    /**
     * Handle close window button.
     */
    public void processEvent(e) {
        if (e.getID() == Event.WINDOW_DESTROY) {
            close();
        }
    }
}

GameOfLife.main(ARGV);
